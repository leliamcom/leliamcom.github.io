{"data":[{"author":{"avatar":{"url":"/assets/32x32_avatar.jpg"},"name":"Liam","slug":"nghenglim","tagline":"Make people great again!"},"banner":{"url":"/assets/2016022000.png"},"cover":{"url":"/assets/thumb-150-2016022000.png"},"description":"\nWe will use gvm to install go for the current user. Note that we need to use go1.4 to compile go1.5 because go1.5 use go itself as compiler, therefore it need to have go installed.\n\nNote that gvm is mainly for development use, IMHO using tar install or docker is a better way for production server.\n    ","postedAt":"2016-02-19T16:00:00.000Z","shortener":"3oYTmlWx3QBUng4ZzKdm5N","slug":"golang-rest-api","title":"Golang Rest API"},{"author":{"avatar":{"url":"/assets/32x32_avatar.jpg"},"name":"Liam","slug":"nghenglim","tagline":"Make people great again!"},"banner":{"url":"/assets/2015091900.jpg"},"cover":{"url":"/assets/thumb-150-2015091900.jpg"},"description":"\nConcurrency is the key to designing high performance network services. Go's concurrency primitives (goroutines and channels) provide a simple and efficient means of expressing concurrent execution. [In this talk we see how tricky concurrency problems can be solved gracefully with simple Go code.](https://www.youtube.com/watch?v=f6kdp27TYZs)\n    ","postedAt":"2015-09-25T16:00:00.000Z","shortener":"2LSpynyF9kHZ7s0GKvmfN6","slug":"go-concurrency-google-io-2012","title":"Go Concurrency (Google IO 2012)"},{"author":{"avatar":{"url":"/assets/32x32_avatar.jpg"},"name":"Liam","slug":"nghenglim","tagline":"Make people great again!"},"banner":{"url":"/assets/2015091900.jpg"},"cover":{"url":"/assets/thumb-150-2015091900.jpg"},"description":"\nA goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.\n    ","postedAt":"2015-09-18T16:00:00.000Z","shortener":"3jo6dR7oeFz5pSq728JtJw","slug":"goroutine","title":"Goroutine"}]}