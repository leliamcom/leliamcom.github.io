<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=css/global.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.ico rel=icon type=image/png> <link href=client/main.963202101.css rel=stylesheet><link href=client/[slug].013927c3.css rel=stylesheet><link href=client/app.af1f08cd.css rel=stylesheet><link href=client/Nav.036c21e8.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Goroutine</title> <meta content="Author: Liam, Date: 19 Sep, 2015\n A goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.
" name=description> <meta content=article name=og:type> <meta content=https://leliam.com/blogposts/goroutine-@3jo6dR7oeFz5pSq728JtJw name=og:url> <meta content=Goroutine name=og:title> <meta content="A goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.\n" name=og:description><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <div style="min-height:calc(100vh - 48px)"> <nav aria-label="main navigation" class="svelte-1dif8ux navbar" role=navigation> <div class=navbar-brand> <a href=/ class="svelte-1dif8ux navbar-item" style=margin:5px><div class="is-4 subtitle">Le Liam</div></a> <a href=/ class="svelte-1dif8ux navbar-item">Home</a> <a href=/tags class="svelte-1dif8ux navbar-item">Tags</a> <a href=/blogposts class="svelte-1dif8ux navbar-item is-active">Blogposts</a> <a href=/contact class="svelte-1dif8ux navbar-item">Contact</a> </div> </nav> <main> <div class="container is-fluid"> <div class=media style="margin:25px 0"> <div class=media-left> <figure class="image is-48x48"> <img alt="Author avatar" loading=lazy src=/assets/32x32_avatar.jpg class=is-rounded> </figure> </div> <div class=media-content> <p class="is-4 title">Liam</p> <p class="subtitle is-6">19 Sep, 2015</p> </div> </div> <div style="margin:0 0 25px"> <img alt="blogpost banner" loading=lazy src=/assets/2015091900.jpg style="margin:0 auto;display:block"> </div> <h3 class=title>Goroutine</h3> <div class="content svelte-nn94v0"> <p>A goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.</p> <h2>Goroutine vs Java thread</h2> <p>Quoting from <a href=http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads/ >this blog</a></p> <ul> <li>On Java you can run 1000’s or tens of 1000’s threads. On Go you can run hundreds of thousands or millions of goroutines.</li> <li>Java threads map directly to OS threads, and are relatively heavyweight. Part of the reason they are heavyweight is their rather large fixed stack size. This caps the number of them you can run in a single VM due to the increasing memory overhead.</li> <li>Go OTOH has a segmented stack that grows as needed. They are “Green threads”, which means the Go runtime does the scheduling, not the OS. The runtime multiplexes the goroutines onto real OS threads, the number of which is controlled by GOMAXPROCS. Typically you’ll want to set this to the number of cores on your system, to maximize potential parellelism.</li> </ul> <h2>Example of goroutine</h2> <p>The example can be found at <a href=https://gobyexample.com/goroutines>gobyexample</a>. The how it work internally can refer to this <a href=http://www.goinggo.net/2015/02/scheduler-tracing-in-go.html>"example"</a>.</p> <p>To summarise, golang achieve concurrency with the implementation of goroutine and <a href=https://gobyexample.com/channels>channel</a>. Goroutine acts as task worker while channel let them achieve "<a href=https://golang.org/doc/codewalk/sharemem/ >Share Memory By Communicating</a>".</p> <h2>Advantage of goroutine</h2> <ul> <li> <p>No callback hell, example at <a href=http://stackoverflow.com/a/23709882>stackoverflow</a></p> <pre class=hljs><code><span class=hljs-comment>//nodejs (if not using async/await or promise)</span>
doSomething1(arg1, arg2, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
  doSomething2(arg1, arg2, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
    doSomething3(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
      <span class=hljs-comment>// done</span>
    });
  });
});
somethingElse();
</code></pre> <pre class=hljs><code><span class=hljs-comment>//golang</span>
<span class=hljs-keyword>go</span> <span class=hljs-function><span class=hljs-keyword>func</span><span class=hljs-params>()</span></span> {
  doSomething1(arg1, arg2)
  doSomething2(arg1, arg2)
  doSomething3()
  <span class=hljs-comment>// done</span>
}()
somethingElse()
</code></pre> </li> <li> <p>Faster startup time and light weight than threads = run more, run faster</p> </li> </ul> </div> </div> </main> </div> <footer style=height:48px;padding:10px> <div class="content has-text-centered"> <a href=/privacy-policy>privacy policy</a> · ©2018-2020 Le Liam · <a href=/terms-of-service>TOS</a> </div> </footer></div> <script crossorigin=anonymous src="https://polyfill.io/v3/polyfill.min.js?features=fetch%2CPromise"></script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{slug:"goroutine-@3jo6dR7oeFz5pSq728JtJw",title:"Goroutine",description:"\u003Cp\u003EA goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.\u003C\u002Fp\u003E\n",banner:"\u002Fassets\u002F2015091900.jpg",author:{avatar:"\u002Fassets\u002F32x32_avatar.jpg",name:"Liam"},data:"\u003Cp\u003EA goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.\u003C\u002Fp\u003E\n\u003Ch2\u003EGoroutine vs Java thread\u003C\u002Fh2\u003E\n\u003Cp\u003EQuoting from \u003Ca href=\"http:\u002F\u002Ftleyden.github.io\u002Fblog\u002F2014\u002F10\u002F30\u002Fgoroutines-vs-threads\u002F\"\u003Ethis blog\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EOn Java you can run 1000’s or tens of 1000’s threads. On Go you can run hundreds of thousands or millions of goroutines.\u003C\u002Fli\u003E\n\u003Cli\u003EJava threads map directly to OS threads, and are relatively heavyweight. Part of the reason they are heavyweight is their rather large fixed stack size. This caps the number of them you can run in a single VM due to the increasing memory overhead.\u003C\u002Fli\u003E\n\u003Cli\u003EGo OTOH has a segmented stack that grows as needed. They are “Green threads”, which means the Go runtime does the scheduling, not the OS. The runtime multiplexes the goroutines onto real OS threads, the number of which is controlled by GOMAXPROCS. Typically you’ll want to set this to the number of cores on your system, to maximize potential parellelism.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EExample of goroutine\u003C\u002Fh2\u003E\n\u003Cp\u003EThe example can be found at \u003Ca href=\"https:\u002F\u002Fgobyexample.com\u002Fgoroutines\"\u003Egobyexample\u003C\u002Fa\u003E. The how it work internally can refer to this\n\u003Ca href=\"http:\u002F\u002Fwww.goinggo.net\u002F2015\u002F02\u002Fscheduler-tracing-in-go.html\"\u003E&quot;example&quot;\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003ETo summarise, golang achieve concurrency with the implementation of goroutine and \u003Ca href=\"https:\u002F\u002Fgobyexample.com\u002Fchannels\"\u003Echannel\u003C\u002Fa\u003E. Goroutine acts as task worker while channel let them achieve &quot;\u003Ca href=\"https:\u002F\u002Fgolang.org\u002Fdoc\u002Fcodewalk\u002Fsharemem\u002F\"\u003EShare Memory By Communicating\u003C\u002Fa\u003E&quot;.\u003C\u002Fp\u003E\n\u003Ch2\u003EAdvantage of goroutine\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ENo callback hell, example at \u003Ca href=\"http:\u002F\u002Fstackoverflow.com\u002Fa\u002F23709882\"\u003Estackoverflow\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fnodejs (if not using async\u002Fawait or promise)\u003C\u002Fspan\u003E\ndoSomething1(arg1, arg2, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  doSomething2(arg1, arg2, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    doSomething3(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F done\u003C\u002Fspan\u003E\n    });\n  });\n});\nsomethingElse();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002Fgolang\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Ego\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  doSomething1(arg1, arg2)\n  doSomething2(arg1, arg2)\n  doSomething3()\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F done\u003C\u002Fspan\u003E\n}()\nsomethingElse()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EFaster startup time and light weight than threads = run more, run faster\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n",postedAt:"19 Sep, 2015",metaDescription:"A goroutine is a lightweight thread managed by the Go runtime to support concurrency. It is considered a better mechanism than nodejs event event loop or normal thread.\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.8960e12d.js"}catch(e){main="/client/legacy/client.2891bd2a.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script> function trim(text, val) {
		return text.replace(new RegExp('^'+val+'+|'+val+'+$','g'), '');
	}
	if (document.title === "Not Found") {
		let paths = trim(window.location.pathname, "/").split("-@");
		if (paths.length > 1) {
			fetch(`/blogposts/shortener-${paths[paths.length - 1]}.json`)
			.then((data) => {
				return data.json()
			})
			.then((data) => {
				window.location.replace(`/blogposts/${data.slug}`);
			})
			.catch((err) => {
				console.log(err);
			})
		}
	} </script> 