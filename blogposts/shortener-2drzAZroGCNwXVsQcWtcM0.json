{"slug":"rust-for-web-development-part-1-@2drzAZroGCNwXVsQcWtcM0","title":"Rust For Web Development Part 1","description":"<p>With the asynchronous I/O libraries of Rust is mostly ready, Rust can  serve web traffic without being I/O bound. However, the only downside is that framework is not mature yet.</p>\n<h3>Edit on year Jun 19, 2018</h3>\n<p>Project has been discontinued due to Rust still does not support Async/Await which i think is crucial for web development</p>\n","banner":null,"author":{"avatar":"/assets/32x32_avatar.jpg","name":"Liam"},"data":"<h2>Edit on year Jun 19, 2018</h2>\n<p>Project has been discontinued due to Rust still does not support Async/Await which i think is crucial for web development</p>\n<h2>Intro</h2>\n<p>If you ask what is the rising star of programming language, it will be rust for recent year.</p>\n<h2>Potential of Rust in Web Development</h2>\n<ul>\n<li>Execution Speed</li>\n<li>No garbage collection (as compared to JAVA or GO web development)</li>\n<li>Build in code safety</li>\n<li>Compile to binary</li>\n</ul>\n<h2>Is 2018 the right time to use Rust for web development?</h2>\n<p>With the asynchronous I/O libraries of Rust is mostly ready, Rust can  serve web traffic without being I/O bound. However, the only downside is that framework is not mature yet.</p>\n<h2>Top Web Development Framework For Rust</h2>\n<ul>\n<li>Iron: Not much investigate into it, but seems like not as maintained as Rocket</li>\n<li>Rocket: Currently(0.3.6) is build on synchronous HTTP backend. Provide higher level of abstraction however has less control on what you can do.</li>\n<li>Hyper: Hyper(0.11) is multithreaded asynchronous low-level typesafe abstraction over raw HTTP. However the example on it is not much and too low-level.</li>\n</ul>\n<h2>Time for Develop a new Framework?</h2>\n<p>Well I actually think making a wrapper on top of Hyper will be good enough! I currently name it as <a href=\"https://github.com/nghenglim/hyperap\">Hyperap</a> and published it to <a href=\"https://github.com/nghenglim/hyperap\">Github</a>! Have not publish to crates.io yet because I have some issue login into it.</p>\n<p>The code is still in development, I plan to use it as the main framework for my pet project.</p>\n<h2>Example Usage</h2>\n<p>To test it (assumed you have rust cargo installed)</p>\n<pre class=\"hljs\"><code>git <span class=\"hljs-built_in\">clone</span> https://github.com/nghenglim/hyperap\n<span class=\"hljs-built_in\">cd</span> hyperap &amp;&amp; cargo run\n</code></pre>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-keyword\">crate</span> hyperap;\n<span class=\"hljs-keyword\">use</span> hyperap::hyper::server::{Response};\n<span class=\"hljs-keyword\">use</span> hyperap::hyper::{Method};\n<span class=\"hljs-keyword\">use</span> hyperap::server::{HyperApp, Middleware, MiddlewareParam};\n<span class=\"hljs-keyword\">use</span> hyperap::response::{resp};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">get_static</span></span>(_a: MiddlewareResult) -&gt; Response {\n    hyperap::server::static_file(<span class=\"hljs-string\">\"Cargo.toml\"</span>)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">hello_world</span></span>(a: MiddlewareResult) -&gt; Response {\n    resp(a.hello.clone() + <span class=\"hljs-string\">\" at path \"</span> + &amp;a.path)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">not_found_route</span></span>(a: MiddlewareResult) -&gt; Response {\n    resp(<span class=\"hljs-string\">\"not found route at path \"</span>.to_owned() + &amp;a.path)\n}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">App</span></span> {\n    <span class=\"hljs-keyword\">pub</span> hello: <span class=\"hljs-built_in\">String</span>,\n}\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MiddlewareResult</span></span> {\n    path: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-keyword\">pub</span> hello: <span class=\"hljs-built_in\">String</span>,\n}\n<span class=\"hljs-meta\">#[derive(Clone)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RouteDefinition</span></span> {\n    parameters: <span class=\"hljs-built_in\">Vec</span>&lt;RouteDefinitionParameters&gt;\n}\n<span class=\"hljs-meta\">#[derive(Clone)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">RouteDefinitionParameters</span></span> {\n    _<span class=\"hljs-keyword\">in</span>: <span class=\"hljs-built_in\">String</span>,\n    _name: <span class=\"hljs-built_in\">String</span>,\n}\n<span class=\"hljs-keyword\">impl</span> Middleware <span class=\"hljs-keyword\">for</span> App {\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">M</span></span> = MiddlewareResult;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">R</span></span> = RouteDefinition;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">middleware</span></span>(&amp;<span class=\"hljs-keyword\">self</span>, p: MiddlewareParam&lt;MiddlewareResult, Self::R&gt;) -&gt; Response {\n        <span class=\"hljs-keyword\">let</span> m = MiddlewareResult {\n            path: p.req.path().to_owned(),\n            hello: <span class=\"hljs-keyword\">self</span>.hello.clone(),\n        };\n        (p.func)(m)\n    }\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">main</span></span>() {\n    <span class=\"hljs-keyword\">let</span> the_app = App {\n        hello: <span class=\"hljs-string\">\"Hello World\"</span>.to_owned(),\n    };\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut</span> app = HyperApp::new(the_app);\n    app.open_browser(<span class=\"hljs-literal\">true</span>);\n    app.set_default_route(not_found_route);\n    app.add_route(Method::Get, <span class=\"hljs-string\">\"/static\"</span>, get_static, <span class=\"hljs-built_in\">vec!</span>[RouteDefinition {\n        parameters: <span class=\"hljs-built_in\">vec!</span>[RouteDefinitionParameters {\n            _<span class=\"hljs-keyword\">in</span>: <span class=\"hljs-string\">\"query\"</span>.to_owned(),\n            _name: <span class=\"hljs-string\">\"offset\"</span>.to_owned(),\n        }]\n    }]);\n    app.add_pure_route(Method::Get, <span class=\"hljs-string\">\"/\"</span>, hello_world);\n    app.port(<span class=\"hljs-number\">3000</span>);\n    app.run();\n}\n</code></pre>\n<h2>Other critical part in web development</h2>\n<ul>\n<li>ORM: with feature similar to <a href=\"https://github.com/sequelize/sequelize\">Sequelize</a></li>\n<li>Query builder\nThere seems to be some libraries for it, however coming from NodeJS, the feature that these libraries just cannot fulfill my need.</li>\n</ul>\n<p>I'm currently working on making a rust ORM library. However most probably will remain as my private repo unless a lot of people interested on it.</p>\n","postedAt":"01 Feb, 2018","metaDescription":"With the asynchronous I/O libraries of Rust is mostly ready, Rust can  serve web traffic without being I/O bound. However, the only downside is that framework is not mature yet.\nEdit on year Jun 19, 2018\nProject has been discontinued due to Rust still does not support Async/Await which i think is crucial for web development\n"}